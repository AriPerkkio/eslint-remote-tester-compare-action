import fs from 'fs';
import { exec } from '@actions/exec';

import runTester from '../src/run-tester';
import { ESLINT_REMOTE_TESTER_BIN } from '../src/peer-dependencies';
import { sanitizeStackTrace } from './utils';

const EXPECTED_RUN_CONFIG = './eslint-remote-tester-compare-internal.config.js';
const EXISTING_CONFIG = './test/eslint-remote-tester.config.js';
const EXISTING_CONFIG_WITH_ON_COMPLETE =
    './test/eslint-remote-tester.config.2.js';

jest.mock('@actions/exec', () => ({ exec: jest.fn() }));

function readRunConfig(asText = true) {
    const content = fs.readFileSync(EXPECTED_RUN_CONFIG, 'utf8');
    if (asText) return content;

    // require doesn't work here even when combined with jes.resetModules
    return eval(content);
}

function cleanup() {
    if (fs.existsSync(EXPECTED_RUN_CONFIG)) {
        fs.unlinkSync(EXPECTED_RUN_CONFIG);
    }
}

describe('run-tester', () => {
    beforeEach(cleanup);
    afterEach(cleanup);

    test('runs eslint-remote-tester with internal configuration', async () => {
        await runTester(EXISTING_CONFIG, {});

        expect(exec).toHaveBeenCalledWith(
            `${ESLINT_REMOTE_TESTER_BIN} --config ${EXPECTED_RUN_CONFIG}`,
            [],
            {
                ignoreReturnCode: true,
                env: expect.objectContaining({
                    NODE_OPTIONS: '--max_old_space_size=5120',
                }),
            }
        );
    });

    test('throws if given configuration does not exist', () => {
        return expect(() =>
            runTester('./non-existing-config', {})
        ).rejects.toThrowError(
            /(?=.*Unable to find eslint-remote-tester config with path)(?=.*non-existing-config)/
        );
    });

    test('merges user provided configuration with internal values', async () => {
        await runTester(EXISTING_CONFIG, {});

        expect(readRunConfig()).toMatchInlineSnapshot(`
            "// Generated by eslint-remote-tester-compare-action
            const fs = require('fs');

            module.exports = {
                ...{
                \\"resultParser\\": \\"markdown\\",
                \\"repositories\\": [
                    \\"AriPerkkio/eslint-remote-tester-integration-test-target\\"
                ],
                \\"extensions\\": [
                    \\".js\\"
                ],
                \\"pathIgnorePattern\\": \\"(expected-to-be-excluded)\\",
                \\"rulesUnderTesting\\": [
                    \\"no-unreachable\\",
                    \\"no-undef\\",
                    \\"no-empty\\",
                    \\"getter-return\\",
                    \\"no-compare-neg-zero\\"
                ],
                \\"eslintrc\\": {
                    \\"root\\": true,
                    \\"extends\\": [
                        \\"eslint:recommended\\"
                    ]
                },
                \\"CI\\": true,
                \\"compare\\": true,
                \\"updateComparisonReference\\": true,
                \\"cache\\": false
            },
                onComplete: async function onComplete(results, comparisonResults) {
                    fs.writeFileSync('/tmp/comparison-results.json', JSON.stringify(comparisonResults || {}));

                    // User provided onComplete is injected here if present
                    // Argument from comment overrides user-provided configuration
                    // No onComplete detected
                }
            };
            "
        `);
    });

    test('merges configuration from comment with internal values', async () => {
        await runTester(EXISTING_CONFIG, {
            rulesUnderTesting: ['my-rule'],
            extensions: ['.mjs'],
        });

        expect(readRunConfig()).toMatchInlineSnapshot(`
            "// Generated by eslint-remote-tester-compare-action
            const fs = require('fs');

            module.exports = {
                ...{
                \\"resultParser\\": \\"markdown\\",
                \\"repositories\\": [
                    \\"AriPerkkio/eslint-remote-tester-integration-test-target\\"
                ],
                \\"extensions\\": [
                    \\".mjs\\"
                ],
                \\"pathIgnorePattern\\": \\"(expected-to-be-excluded)\\",
                \\"rulesUnderTesting\\": [
                    \\"my-rule\\"
                ],
                \\"eslintrc\\": {
                    \\"root\\": true,
                    \\"extends\\": [
                        \\"eslint:recommended\\"
                    ]
                },
                \\"CI\\": true,
                \\"compare\\": true,
                \\"updateComparisonReference\\": true,
                \\"cache\\": false
            },
                onComplete: async function onComplete(results, comparisonResults) {
                    fs.writeFileSync('/tmp/comparison-results.json', JSON.stringify(comparisonResults || {}));

                    // User provided onComplete is injected here if present
                    // Argument from comment overrides user-provided configuration
                    // No onComplete detected
                }
            };
            "
        `);
    });

    test('merges eslintrc configurations', async () => {
        await runTester(EXISTING_CONFIG, {
            eslintrc: { rules: { 'no-undef': 'off' } },
        });

        expect(readRunConfig(false).eslintrc).toMatchInlineSnapshot(`
            Object {
              "extends": Array [
                "eslint:recommended",
              ],
              "root": true,
              "rules": Object {
                "no-undef": "off",
              },
            }
        `);
    });

    test('uses onComplete from comment', async () => {
        await runTester(EXISTING_CONFIG, {
            onComplete: () => console.log('Hello world'),
        });

        expect(readRunConfig(false).onComplete.toString())
            .toMatchInlineSnapshot(`
            "async function onComplete(results, comparisonResults) {
                    fs.writeFileSync('/tmp/comparison-results.json', JSON.stringify(comparisonResults || {}));

                    // User provided onComplete is injected here if present
                    // Argument from comment overrides user-provided configuration
                    await (() => console.log('Hello world'))(results, comparisonResults)
                }"
        `);
    });

    test('uses onComplete from users configuration', async () => {
        await runTester(EXISTING_CONFIG_WITH_ON_COMPLETE, {});

        expect(sanitizeStackTrace(readRunConfig(false).onComplete.toString()))
            .toMatchInlineSnapshot(`
            "async function onComplete(results, comparisonResults) {
                    fs.writeFileSync('/tmp/comparison-results.json', JSON.stringify(comparisonResults || {}));

                    // User provided onComplete is injected here if present
                    // Argument from comment overrides user-provided configuration
                    await require('<removed>/test/eslint-remote-tester.config.2.js').onComplete(results, comparisonResults);
                }"
        `);
    });

    test('configuration is validated', () => {
        const consolelog = console.log;
        console.log = jest.fn();

        return expect(() => runTester(EXISTING_CONFIG, { repositories: [] }))
            .rejects.toThrowErrorMatchingInlineSnapshot(
                `
                    "Configuration validation errors:
                    - Missing repositories."
                `
            )
            .then(() => (console.log = consolelog));
    });
});
